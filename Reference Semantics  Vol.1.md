->In assembly we can think references as;

Type * const ptr = &x; 

-> Reference Variables can not intialize with default initialization. 
-> Reference variable can only be reference to L value expression. 
-> Reference type must be the same with referenced expression.

Example 1:

int main(){
  int x{10};
  int &r = x; // r is bound to x. 
}

-> In assembly, running codes are the same with the example below;

int main(){
  int x{10};
  int *ptr = &x;
}

Example 2:

int x = 10;
// double &r =x; Not correct. 
int &r = x; // Correct.

Example 3:

int x = 10;
int* p = &x;
int* &r = p;

Example 4:

int** ptr{};
int** &r = ptr;

Example 5:

int x = 10;
int &r = x;
std::cout<<"&r ="<<&r<<'\n';
std::cout<<"&x ="<<&x<<'\n';

//The code piece above prints the adresses of r and x. As a output we see that they are the same. Hence, &r = &x and r=x. 

-> References can be initialized as;

int x{10};
int &r1 = x;
int &r2(x);
int &r3{x};

// We can increment or decrement the value of x by changing r1,r2 or r3.

++r1;
++r2;
++r3;

// x is now 13. 

-> References can not be value initialized. 

int &r{}; // NOT CORRECT. 

-> Functions that have reference return type can be initialized as;

int &r(); //Function Initialization. 






